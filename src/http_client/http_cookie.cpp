#pragma warning(disable:4996)

#include "http_client/http_cookie.h"
#include <sstream>
#include <cstring>

using namespace http_client;

HttpCookie::HttpCookie(const std::string &fullPathFilename) :
        cookieFilename_(fullPathFilename) {

}

void HttpCookie::read_file() {
    std::string strFile = get_string_from_file(cookieFilename_);
    if (strFile.empty()) return;

    std::vector<std::string> cookieVec;
    std::stringstream stream(strFile);
    std::string item;

    while (std::getline(stream, item, '\n')) {
        cookieVec.push_back(item);
    }
    if (cookieVec.empty()) return;

    cookies_.clear();

    for (auto &cookie: cookieVec) {
        if (cookie.empty()) continue;

        if (cookie.find("#HttpOnly_") != std::string::npos) {
            cookie.substr(10);
        }

        if (cookie[0] == '#') continue;

        CookieInfo co;
        std::stringstream streamInfo(cookie);
        std::vector<std::string> elems;
        std::string line;

        while (std::getline(streamInfo, line, '\t')) {
            elems.push_back(line);
        }

        co.domain = elems[0];
        if (co.domain[0] == '.') {
            co.domain = co.domain.substr(1);
        }
        co.tailMatch = (strcmp("TRUE", elems[1].data()) == 0) ? true : false;
        co.path = elems[2];
        co.secure = (strcmp("TRUE", elems[3].data()) == 0) ? true : false;
        co.expires = elems[4];
        co.name = elems[5];
        co.value = elems[6];

        cookies_.push_back(co);
    }
}

std::string HttpCookie::get_string_from_file(const std::string &fullPathFilename) {
    std::string result;
    if (fullPathFilename.empty()) return result;

    FILE *fp = fopen(fullPathFilename.data(), "r");
    if (fp) {
        char buf[64 * 1024];
        size_t readSize = 0;

        while (true) {
            readSize = fread(buf, sizeof(char), sizeof(buf), fp);
            if (readSize > 0) {
                result.append(buf, readSize);
            } else {
                if (errno) {
                    fprintf(stderr, "get_string_from_file() failed! %s\n", strerror(errno));
                }
                break;
            }
        }
    } else {
        int savedErrno = errno;
        fprintf(stderr, "get_string_from_file() failed! %s\n", strerror(savedErrno));
    }
    fclose(fp);

    return result;
}

void HttpCookie::write_file() {
    FILE *out = fopen(cookieFilename_.data(), "w");
    fputs("# Netscape HTTP Cookie File\n"
          "# http://curl.haxx.se/docs/http-cookies.html\n"
          "# This file was generated by HttpClient! Edit at your own risk.\n"
          "# Test HttpClient cookie write",
          out);

    std::string line;
    for (auto &item: cookies_) {
        line.clear();
        line.append(item.domain);
        line.append(1, '\t');
        item.tailMatch ? line.append("TRUE") : line.append("FALSE");
        line.append(1, '\t');
        line.append(item.path);
        line.append(1, '\t');
        item.secure ? line.append("TRUE") : line.append("FALSE");
        line.append(1, '\t');
        line.append(item.expires);
        line.append(1, '\t');
        line.append(item.name);
        line.append(1, '\t');
        line.append(item.value);

        fputs(line.data(), out);
    }

    fclose(out);
}

const std::vector<CookieInfo> *HttpCookie::get_cookies() const {
    return &cookies_;
}

const CookieInfo *HttpCookie::get_match_cookie(const std::string &url) const {
    for (auto &cookie: cookies_) {
        if (url.find(cookie.domain) != std::string::npos) {
            return &cookie;
        }
    }

    return nullptr;
}

void HttpCookie::update_or_add_cookie(const CookieInfo &cookie) {
    for (auto &item: cookies_) {
        if (cookie.domain == item.domain) {
            item = cookie;
            return;
        }
    }

    cookies_.push_back(cookie);
}